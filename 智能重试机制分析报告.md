# 智能重试机制分析报告

**日期**: 2026-01-02

---

## 问题描述

在批量下载京东业绩公告PDF时，2024年度报告首次下载失败（fetch失败），原因是文件较大（3.6MB）而等待时间不够（8秒）。

**当前代码的问题**：
```javascript
await new Promise(r => setTimeout(r, 8000));  // 固定8秒等待
const data = await page.evaluate(async () => {
    const r = await fetch(location.href, { credentials: 'include' });
    // 失败了就直接返回错误，没有重试
    if (!r.ok) return { err: r.status };
    return {...};
});
```

**缺失的功能**：
1. ❌ 没有失败重试机制
2. ❌ 等待时间固定不智能
3. ❌ 没有根据文件大小动态调整

---

## 智能重试机制设计

### 1. 自动重试（指数退避）

```javascript
async function fetchWithRetry(page, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            const data = await page.evaluate(async () => {
                const r = await fetch(location.href, { credentials: 'include' });
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                return Array.from(new Uint8Array(await r.arrayBuffer()));
            });
            return { ok: true, data };
        } catch (e) {
            const delay = Math.pow(2, i) * 2000;  // 2s, 4s, 8s
            console.log(`  重试 ${i + 1}/${maxRetries}，等待 ${delay/1000}s...`);
            await new Promise(r => setTimeout(r, delay));
        }
    }
    return { error: '重试次数用尽' };
}
```

### 2. 动态等待时间

根据文件类型/大小调整等待时间：

```javascript
function getWaitTime(fileType) {
    const waitTimes = {
        '季度': 8000,    // 季报较小
        '年度报告': 20000,  // 年报较大，3-5MB
        '中期': 12000,   // 半年报中等
        'default': 10000
    };
    
    for (const [key, time] of Object.entries(waitTimes)) {
        if (fileType.includes(key)) return time;
    }
    return waitTimes.default;
}
```

### 3. 下载验证

确认下载的是有效PDF：

```javascript
function validatePdf(buffer) {
    // 检查PDF头
    const header = buffer.slice(0, 5).toString();
    if (header !== '%PDF-') return { valid: false, reason: '不是有效PDF' };
    
    // 检查最小大小（至少10KB）
    if (buffer.length < 10240) return { valid: false, reason: '文件太小' };
    
    return { valid: true };
}
```

### 4. 完整的智能下载函数

```javascript
async function smartDownloadPdf(page, url, fileName) {
    const maxRetries = 3;
    const waitTime = getWaitTime(fileName);
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        console.log(`[${attempt}/${maxRetries}] 下载: ${fileName}`);
        
        try {
            await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 60000 });
            await new Promise(r => setTimeout(r, waitTime));
            
            const data = await page.evaluate(async () => {
                const r = await fetch(location.href, { credentials: 'include' });
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                return Array.from(new Uint8Array(await r.arrayBuffer()));
            });
            
            const buffer = Buffer.from(data);
            const validation = validatePdf(buffer);
            
            if (validation.valid) {
                fs.writeFileSync(filePath, buffer);
                console.log(`  ✅ 成功: ${(buffer.length / 1024).toFixed(0)} KB`);
                return { success: true };
            } else {
                throw new Error(validation.reason);
            }
            
        } catch (e) {
            console.log(`  ❌ 失败: ${e.message}`);
            if (attempt < maxRetries) {
                const delay = attempt * 5000;  // 5s, 10s
                console.log(`  等待 ${delay/1000}s 后重试...`);
                await new Promise(r => setTimeout(r, delay));
            }
        }
    }
    
    return { success: false, error: '重试次数用尽' };
}
```

---

## 行动计划

1. **立即实施**：将智能重试机制集成到下载脚本
2. **更新TODO**：记录此改进作为成功经验
3. **应用到所有爬虫**：检查项目中其他爬虫是否有类似问题

---

## 教训总结

| 问题 | 原因 | 解决方案 |
|-----|------|---------|
| 大文件下载失败 | 等待时间固定不够 | 根据文件类型动态调整 |
| 失败后需要手动重试 | 没有自动重试机制 | 指数退避重试 |
| 不知道是否下载成功 | 没有验证机制 | 验证PDF头和大小 |
